# DETECT A CYCLE IN A LINKED LIST
# 
# Given head, the head of a linked list,
# determine if the linked list has a cycle in it.
# There is a cycle in a linked list if there is some
# node in the list that can be reached again by
# continuously following the next pointer.
# Internally, pos is used to denote the index of the
# node that tail's next pointer is connected to.
# Note that pos is not passed as a parameter.
# Return true if there is a cycle in the linked list.
# Otherwise, return false.

Node(value)
{
    ret &{ .value : value, .next : null };
}

Push(nodes, node)
{
    node@next := nodes;
    nodes = node;
}

HasCycle(nodes)
{
    walker := nodes;
    runner := nodes;
    while(true)
    {
        if(runner@next == null)
        {
            break;
        }
        if(runner@next@next == null)
        {
            break;
        }
        walker = walker@next;
        runner = runner@next@next;
        if(walker == runner)
        {
            ret true;
        }
    }
    ret false;
}

Build()
{
    nodes := Node(1);
    Push(nodes, Node(2));
    loop := nodes;
    Push(nodes, Node(3));
    Push(nodes, Node(4));
    Push(nodes, Node(5));
    Push(nodes, Node(6));
    Push(nodes, Node(7));
    Push(nodes, loop);
    ret nodes;
}

Main()
{
    nodes := Build();
    Assert(HasCycle(nodes));
    ret 0;
}
